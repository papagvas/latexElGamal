\documentclass[a4paper,12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[top=20mm, bottom=20mm, left=25mm, right=15mm]{geometry}
\usepackage{graphicx}
\usepackage{fancybox}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{color}

\definecolor{darkgreen}{rgb}{0, 0.5, 0}
\definecolor{graylight}{rgb}{0.6, 0.6, 0.6}

\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}

\title{Формальная спецификация схемы Эль-Гамаля \\
  \large Небольшое введение в CertiCrypt\footnote{Эта работа была частично проспонсирована проектом ANR: SCALP}
}

\author{Жилль Барте, Бенжамен Грегор, Сильвен Херо \\ и Сантьяго Занелла Бегулен}



\begin{document}

\thispagestyle{empty}

\begin{center}

\sc
ФЕДЕРАЛЬНОЕ  ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ
ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ
«НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ
«ВЫСШАЯ ШКОЛА ЭКОНОМИКИ»
\end{center}

\begin{center}
\bf Московский институт электроники и математики им.~А.Н.~Тихонова
\end{center}

\vspace{1cm}

\begin{center}
Гвасалиа Метью
\end{center}

\vspace{1cm}

\begin{center}
\bf Перевод статьи Жиля Барте и др. "Формальная спецификация схемы Эль-Гамаля"
\end{center}

\vspace{10mm}

\begin{center}
Курсовая работа \par
по специальности 10.05.01 «Компьютерная безопасность» \par
студента образовательной программы специалитета
\end{center}

\vfill

\begin{multicols}{2}
\begin{flushleft}
~Студент\par\:\par
\begin{tabular}{c}
\underline{\hspace{8em}} \vspace{-2mm}\\
{\tiny {\color{graylight}подпись}}
\end{tabular}
\begin{tabular}{c}
\underline{\hspace{2em}Гвасалиа Метью\hspace{1em}}\\
{\tiny{\color{graylight} ФИО}}
\end{tabular}
\end{flushleft}

\begin{flushright}
Преподаватель

доцент
\end{flushright}

\begin{tabular}{c}
\underline{\hspace{8em}} \vspace{-1mm}\\
{\tiny {\color{graylight}подпись}}
\end{tabular}
\begin{tabular}{c}
\underline{\hspace{2em}Нестеренко А.Ю.\hspace{1em}} \vspace{-1mm}\\
{\tiny{\color{graylight} ФИО}}
\end{tabular}
\end{multicols}

\vfill
\begin{center}Москва, 2021 г.\end{center}

\newpage

\tableofcontents



\abstract{\textbf{CertiCrypt} \cite{1} - фреймворк, который позволяет создавать верифицируемые компьютером криптографические доказательства, которые могут быть автоматически проверены третьей стороной. На данный момент, \textbf{CertiCrypt} использовался для формального доказательства стойкости хорошо изученных криптогрфических схем, таких как OAEP (Оптимальное асимметричное шифрование с дополнением) и FDH. Цель данной статьи - введение читателя в CertiCrypt на простом и наглядном примере - семантическая стойкость хешированной схемы Эль-Гамаля в моделях со стандартным и случайным оракулом.}

\chapter{Введение}
\textbf{CertiCrypt} \cite{1} - фреймворк, который позволяет создавать верифицируемые компьютером криптографические доказательства в стиле доказуемой криптостойкости \cite{2, 3}. Согласно данному стилю, взаимодействие между схемой и злоумышленником должно быть точно описано, и доказательство стойкости в данном случае дожно быть строгим. \textbf{CertiCrypt} основан на игровом подходе к криптографическим доказательствам \cite{4,5,6}. Данный подход использует техники, которые позволяют понизить сложность криптографических доказательств, представляя доказательства в виде шагов адекватного размера. На данный момент, \textbf{CertiCrypt} использовался для формального доказательства стойкости хорошо изученных криптогрфических схем, таких как OAEP (Оптимальное асимметричное шифрование с дополнением) и FDH, и для установления возможности широкого применения данного фреймворка в криптографических доказательствах, например доказательства леммы об эвивалентности стойкости PRP и PRF и фундаментальной леммы игр. 
\par
\textbf{CertiCrypt} написан на интерактивном средстве доказательства теорем Coq \cite{7}, благодоря которому CertiCrypt обладает высоким уровнем надежности и способностью предоставлять доказательства того, что доказательства верны. Одной из целей проекта является увелечение доверия к криптографическим доказательствам. Что неудивительно, ведь построение доказательства криптостойкости может быть настолько тонким делом, что некоторые схемы известны своими неубедительными доказательствами криптостойкости, которые не могли опровергнуть спустя годы. Ситуация еще хуже, так как есть сомнения в криптографических доказательствах в целом \cite{4, 5}. Возможным решением данной проблемы является предложение Халеви \cite{5} создать и использовать специальные инструменты (для доказательств), он также указал некоторые свойства, которыми данные инструменты должны обладать. В каком-то смысле \textbf{CertiCrypt} является первым шагом на пути к завершению программы Халеви, несмотря на то, что CertiCrypt скорее предоставляет автоматизацию, выразительность и высокий уровень надеждности, а не предоставляет интерфейс для наброска доказательств.
\par
Главной сложностью при создании инструмента для верификации криптографических доказательств является то, что данные доказательства обычно содержат широкий набор концепций и рассуждений из мира теории вероятностей, теории груп и теории сложности вычислений. В случае игрового подхода, доказательства еще опираются на семантику языков программирования и на трансформацию програм и их верификацию. Несмотря на то, что все эти аспекты учтены в \textbf{CertiCrypt}, впервые мы затрагиваем некоторые необходимые детали, которые возникают при использовании инструмента для построения конкретного доказательства.
\par
Цель данной статьи - введение читателя в CertiCrypt. Мы предоставляем пошаговые доказательства стойкости хешированной схемы Эль-Гамаля, надеясь, что это поможет читателям понять некоторые тонкие детали фреймворка. В продолжение статьи вводной статьи Шупа о доказательствах, основанных на играх, мы предъявляем доказательства в стандартной модели и в модели со случайным оракулом, предполагая, что хэш функцию нельзя отличить от чисто случайной функции. Эти доказательства обощают наше прошлое доказательство стойкости схемы Эль-Гамаля, которое было кратко описано в \cite{1}.

\chapter{Доказуемая стойкость и техника, основанная на играх}

Цель криптографии - достичь определенного уровня криптостойкости. независимо от поведения злоумышленников. Однако нельзя просто перечислить все способы, которые злоумышленники могут использовать для взлома схемы, и создать идеальную криптосхему. Подобная методология обречена на провал, поскольку злоумышленники будут действовать непредсказуемо, чтобы обойти все контрмеры. Именно поэтому правильные доказательства должны установить защищенность от всех потенциальных злоумышленников. Не каждый противник считается потенциальным, на потенциальных противников накладываются определенные ограничения, которые делают возможным доказательство стойкости. В частности, предполагается, что злоумышленник не является всезнающим (например, он не знает какие-то секреты) и всемогущим (не может выполнять трудоемкие вычисления). Оба предположения будут формализованы с помощью управления доступом и ресурсами с одной стороны, и классами сложности с другой.
\par
В игровой технике, которую использует \textbf{CertiCrypt}, криптостойкость выражена через вероятностную программу, в которой отражено взаимодействие между криптосистемой и противником. В этой статье мы будем фокусироваться на системах шифрования с открытым ключом и на их семантической стойкости (или $IND-CPA$ стойкость), которая гарантирует неразличимость шифртекста против атак на основе подобранного шифртекста. Проще говоря, система шифрования с открытым ключом семантически стойкая если ни один потенциальный злоумышленник, зная открытый ключ и выбирая пару сообщений $(m_0, m_1)$, не может определить в каком случае ему был дан результат шифрования $m_0$, а когда - результата шифрования $m_1$. Очевидно, необходимое условие для криптосхемы, удовлетворяющей данному свойству, - быть вероятностной, потому что в другом случае злоумышленник может просто сравнить результат шифрования $m_0$ с шифртекстом, который ему предоставили. В игровом стиле, семантическая стойкость описывается следующей программой:
\begin{figure}
\centering
\ovalbox{
  \begin{Bflushleft}
    \textbf{Игра IND-CPA} 
    $(sk, pk) \gets KG()$; \\
    $(m_0, m_1) \ gets \mathcal{A}(pk)$; \\
    $b \xleftarrow{\$} {0, 1}$; \\
    $\eta \gets Enc(pk, m_b)$; \\
    $b^\prime \gets \mathcal{A}^\prime(pk, \eta) $; \\
    $d \gets b = b^\prime$
  \end{Bflushleft}}
\end{figure}



Здесь $KG$ - алгоритм генерации ключей схемы и $Enc$ - алгоритм шифрования, а $\mathcal{A}$ и $\mathcal{A}^{\prime}$ процедуры представляющие злоумышленника; например в хешированной схеме Эль-Гамаля злоумышленнику предоставлен доступ к случайному оракулу. Спецификация игры $IND-CPA$ завершается указанием того, что злоумышленник относится к классу вероятностных программ, выполняющихся за полиномиальное время, и что у него есть доступ к глобальной переменной для поддержания состояния, доступ только на чтение $pk$, но не имеет доступа к $sk$ или $b$. Есть два способа для управления доступом к переменным: можно определить переменную как локальную, чтобы она была доступна только в области видимости процедуры, или как глобальную, в этом случае доступ будет ограничен явно указанной политикой доступа.
\par
Если схема удовлетворяет свойству $IND-CPA$, вероятность того, что  злоумышленник угадает какое сообщение было зашифровано не значительно больше $\frac{1}{2}$. Точное определение включает в себя параметр стойкости $\eta$ (который определяет параметры схемы) и требует: вероятность того, что $d = 1$ по окончанию игры, или $Pr_{IND-CPA^\eta}[d = 1]$, близка к $\frac{1}{2}$ как функция от $\eta$. Формально, функция $v: \mathbb{N} \mapsto \mathbb{R}$ называется незначительной, тогда и только тогда, когда
\[negligible(v) \myeq \forall c. \exists n_c. \forall n. n \geq n_c \implies \lvert v(n) \rvert \leq n^{-c} \]
Мы считаем, что функция $v$ незначительно близка к константе $k$, когда функция $\lambda\eta.\lvert v(\eta) - k \rvert$ незначительна.
\par
Суть игрового метода заключается в том, что свойство стойкости, такое как $IND-CPA$, доказывается через преобразования оригинальной игры-атаки. Если быть точнее, доказательства, которые следуют игровому методу, организованы как последовательности переходов вида $G, A \rightarrow G^\prime, A^\prime$, где $G$ и $G^\prime$ - игры, а $A$ и $A^\prime$ - события. Цель состоит в том, чтобы установить для каждого перехода неравенство $Pr_G[A] \leq f(Pr_{G^\prime}[A^\prime])$, где $f$ - некоторая монотонная функция. Совмещая последовательно неравенства, полученные из каждого перехода, можно извлечь из игрового доказательства неравенство $Pr_{G_0}[A_0] \leq f(Pr_{G_n}[A_n])$. Таким образом, если $G_0$, $A_0$ обозначают исходную игру-атаку и атаку, можно получить оценку $Pr_{G_0}[A_0]$ из оценки $Pr_{G_n}[A_n]$.
\par
Во многих случаях переходы $G, A \rightarrow G^\prime, A^\prime$ удовлетворяют условию: $Pr_G[A] = Pr_{G^\prime}[A^\prime]$. Такие переходы называются промежуточными этапами, они включают в себя преобразования программы, сохраняющие семантику. Формально сохранение семантики определяется с помощью вероятностного невмешательства [8], поскольку нас интересует только сохранение наблюдаемого поведение игр. Однако во многих случаях сохранение семантики контекстно-зависимо; для учета таких случаев необходимо прибегнуть к реляционной логике, которая обобщает вероятностное невмешательство и позволяет рассуждать о до- и пост- условиях.
\par
Доказательства на основе игрового метода часто опираются на сбои, которые помогают ограничить потерю вероятности при переходах с помощью вероятности появления сбоя. Одним важным инструментом для анализа сбоев является так называемая Фундаментальная лемма: для двух игр $G_1$ и $G_2$, код которых отличается только после поднятия определенного флага (т.е. после присваивания $bad \gets true$, где $bad$ изначально имеет значение false и всегда остается поднятым после установки), можно сделать вывод, что для любого события $A$, $Pr_{G_1}[A \wedge \neg bad] = Pr_{G_2}[A \wedge \neg bad]$. Это, в свою очередь, подразумевает, что
\[\lvert Pr_{G_1}[A] - Pr_{G_2}[A] \rvert \leq Pr_{G_1}[bad] = Pr_{G_2}[bad] \]
при условии, что обе игры заканчиваются с одинаковой вероятностью.
\par
Наконец, некоторые переходы оправданы предположениями. Например, доказательство в разделе 4.2 основано на предположении Диффи-Хеллмана о принятии решения (?) или сокращенно предположении DDH. Для семейства конечных циклических групп это предположение гласит, что ни один эффективный алгоритм не может отличить тройки вида $(g^x, g^y, g^{xy})$ от тройки вида $(g^x, g^y, g^z)$, где $x$, $y$, $z$ равномерно распределены на $\mathbb{Z}_q$, где $q$ - (простой) порядок группы, а $g$ - генератор. Одной из характеристик игровых доказательств является формулировка этих предположений через игры; предположение DDH формулируется следующим образом \\ 
\textbf{Определение 1 (предположение DDH).} \textit{Рассмотрим игры}

\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{0.3\textwidth}
    \centering
 \ovalbox{
  \begin{Bflushleft}
    \textbf{Игра $DDH_0:$} \\  
    $ x,y \xleftarrow{\$} \mathbb{Z}_q$; \\
    $d \gets \mathcal{B}(g^x, g^y, g^{xy}$
  \end{Bflushleft}}
\end{subfigure}
\begin{subfigure}[b]{0.3\textwidth}
  \centering
 \ovalbox{
  \begin{Bflushleft}
    \textbf{Игра $DDH_1:$} \\  
    $ x,y,z \xleftarrow{\$} \mathbb{Z}_q$; \\
    $d \gets \mathcal{B}(g^x, g^y, g^z$
  \end{Bflushleft}}
\end{subfigure}
\end{figure}


и определим
\[ \epsilon_{DDH}(\eta) \myeq \lvert Pr_{DDH^\eta_0}[d = 1] - Pr_{DDH^\eta_1}[d = 1] \rvert  \]
Тогда для каждого $PPT$ злоумышленника $\mathcal{B}$, $\epsilon_{DDH}$ является незначительной функцией. Обратите внимание, что семантика вышеупомянутых игр (и, в частности, порядок $q$ группы) зависит от параметра безопасности $\eta$.
\chapter{Введение в CertiCrypt}
Цель данного раздела заключается в том, чтобы дать краткий обзор фреймворка. Сначала мы покажем синтаксис и семантику языка, используемого для описания игр, а затем инструменты, которые фреймворк предоставляет для их анализа.
\section{Синтаксис и семантика игр}
Самый низкий уровень CertiCrypt - формализация вероятностного языка программирования с вызовами процедур. При заданном наборе $\mathcal{V}$ переменных и наборе $\mathcal{P}$ имен процедур, команды могут быть определены индуктивно с помощью выражений:
\begin{align*}
  \mathcal{I} ::&= \mathcal{V} \gets \mathcal{E} & \text{присваивание} \\
                &\lvert \  \mathcal{V} \xleftarrow{\$} \mathcal{D} & \text{случайное присваивание} \\
                &\lvert \ \text{if } \mathcal{E} \text{ then } \mathcal{C}  \text{ else } \mathcal{C}  & \text{условный оператор} \\
                &\lvert \ \text{while } \mathcal{E} \text{ do } \mathcal{C}  & \text{цикл while} \\
                &\lvert \ \mathcal{V} \gets P(\mathcal{E},  \cdots, \mathcal{E}) & \text{вызов процедуры} \\
  \mathcal{C} ::&= nil & \text{nop}  \\
                &\lvert \ \mathcal{I} \text{ ; } \mathcal{C} & \text{последовательность}   
\end{align*}
где $\mathcal{E}$ - набор выражений, а $\mathcal{D}$ - набор распределений, откуда значения могут быть выбраны во время случайных присваиваний. Есть часто встречающиеся типы данных и операторы, но для адаптации к различным настройкам синтаксис может быть расширен пользователем: пользователи могут определять новые типы данных и операции, предоставляя адекватную интерпретацию в терминах Coq. Кроме того, синтаксис типизован, так что операторы и выражения имеют тотальную семантику.
\par
Игры состоят из основной команды и среды, которая сопоставляет идентификатор процедуры с ее объявлением, состоящим из списка формальных параметров, тела и return выражения (однако при написании игр мы используем явный return)
\[ declaration \myeq \{ params: V^* ; body : \mathcal{C}; re: \mathcal{E} \} \]
Формально, тип игр: $ \mathcal{C} \times ( \mathcal{P} \rightarrow declaration)$. Семантика игр определена с помощью монады меры $M(X)$ Адеба и Полин [9]; конструктор типа, оператор подъема и операция связывания определены следующим образом:
\begin{align*}
  M(X) &\myeq (X \rightarrow [0, 1] \\
  unit &: X \rightarrow M(X) \myeq \lambda x.\lambda f. f x \\
  bind &: M(X) \rightarrow (X \rightarrow M(Y)) \rightarrow M(Y) \\
       &\myeq \lambda \mu. \lambda M. \lambda f. \mu (\lambda x. M x f)
\end{align*}
Эта монада может рассматриваться как специализация монады продолжения и позволяет обеспечить семантику игр в непрерывном стиле. Очевидно, элемент в $M(X)$ может быть интерпретирован как математическое ожидания (суб)распределения вероятностей на $X$. Таким образом, денотация игры связывает начальную память с оператором ожидания (суб) вероятностного распределения конечных воспоминаний, которое является результатом ее выполнения. Денотационная семантика игр определяется внутри с помощью семантики малых шагов, которая использует фреймы для обработки вызовов процедур. Однако с точки зрения пользователя эти детали можно игнорировать, не мешая пониманию; формальное определение семантики малых шагов можно найти в [1]. Обозначение игр представлено на рис. 1; на рисунке мы представляем память $m$ как пару $(m.loc, m.glob)$, явно указывая ее локальные и глобальные компоненты. Выражения детерминированы и их семантика задается функцией $[\![\cdot]\!]_{\epsilon}$, которая вычисляет выражение для заданной памяти и возвращает значение. Семантика распределений в $\mathcal{D}$ задается другой функцией $[\![\cdot]\!]_{\mathcal{D}}$; мы приводим в качестве примеров семантику равномерного распределения на $\mathbb{B}$ и на целых интервалах $[0..n]$. На рисунке мы опустили среду процедуры E для удобства чтения. В дальнейшем мы часто не будем делать различий между игрой $G = (c, E)$ и ее основной командой $c$, когда среда, в которой она вычисляется, либо не важна, либо ясна из контекста.
\begin{figure}[h]
\begin{align*}
 & [\![nil]\!] m & &= unit \  m \\
 & [\![i; c]\!] m & &= bind ( [\![i]\!] m) [\![c]\!] \\
 & [\![x \gets e]\!] m & &= unit \ m\{ [\![e]\!]_\epsilon \frac{m}{x} \} \\
 & [\![x \xleftarrow{\$} d]\!] m & &= bind ( [\![d]\!]_{\mathcal{D}} m ) (\lambda v. unit \ m \{ \frac{v}{x} \}) \\
  & [\![x \gets f(e)]\!] m & &= bind( [\![E(f).body]\!] ( \{ [\![e]\!]_\mathcal{D} \frac{m}{E(f).params}\}, m.glob))\\
  & [\![\text{if } e \text{ then } c_1 \text{ else } c_2 ]\!] m & &= \begin{cases} [\![c_1]\!]  \text{ if } [\![e]\!]_\epsilon m &= true \\ [\![c_2]\!]  \text{ if } [\![e]\!]_\epsilon m &= false \end{cases}
\end{align*}
\caption{Денотационная семантика игр}
\end{figure}
\textbf{CertiCrypt} предоставляет альтернативное, более удобное правила записи циклов while:
\[ [\![while \ e \  do \  c]\!] m \  f = sup\{ [\![[while \  e \  do \  c]_n]\!] m \  f \  : \  n \in \mathbb{N}\}\]
где $[while \ e \ do \ c]_n$ - n-ый шаг цикла, то есть
\begin{align*}
  &[while \ e \ do \ c]_0 &  &= nil \\
  &[while \ e \ do \ c]_{n+1} &  &= if \ e \ then \ c;\ [while \ e \ do \ c]_n
\end{align*}
Обратите внимание, что функция $[\![\cdot]\!]$ отображает $\mathcal{M}$ в $M(\mathcal{M})$, однако очень просто определить функцию $[\![\cdot]\!]^\prime$ из $M(\mathcal{M})$ в $M(\mathcal{M})$ с помощью оператора связывания монады: $[\![G]\!]^\prime \myeq bind \ \mu \ [\![G]\!]$. Главным преимуществом использования монады $M(\mathcal{M})$ является то, что вероятность события $A$, представленная как булевый предикат на памяти, может быть легко определен через характеристическую функцию $\mathbb{I}_A$ вместо $A$:
\begin{equation}\label{eq:eq1}
Pr_{G, m}[A] \myeq [\![G]\!] \  m \ \mathbb{I}_A  
\end{equation}
Далее мы иногда будем опускать начальную память $m$; в таком случае можно спокойно предполагать, что изначально память отображает переменные в значения по умолчанию соответствующего типа.
\section{Анализ игр}
В доказательствах, основанных на игровом методе, переходные этапы в некотором смысле соответствуют преобразованиям, сохраняющим семантику; они используются для повторного определения способа вычисления определенных величин, чтобы подготовить почву для последующего преобразования. Следовательно, на этапе перехода от $G$, $A$ к $G^\prime$, $A^\prime$ цель состоит в том, чтобы установить $Pr_{G,m}[A] = Pr_{G',m}[A']$. Если мы посмотрим на определение \eqref{eq:eq1}, это равносильно доказательству того, что $[\![G]\!] \ m \ \mathbb{I}_A = [\![G']\!] \  m \ \mathbb{I}_{A^\prime} $, или обобщению этого на пару начальных запоминающих устройств $m_1$, $m_2$ и произвольных функций $f$, $g:\mathcal{M} \mapsto [0,1]$, что $ [\![G]\!] \ m_1 \ f = [\![G']\!] \  m_2 \ g $.
\par
Основным инструментом, предоставляемым \textbf{CertiCrypt} для установления таких равенств, является реляционная логика PRHL, которая обобщает реляционную логику Хоара \cite{10} на вероятностный язык. Суждения в pRHL имеют вид $\models G_1 \sim G_2 : \Psi \Rightarrow \Phi $, где $G_1$ и $G_2$ - игры, а $\Psi$ и $\Phi$ - отношения над детерминированными состояниями. Суждение  справедливо $\models G_1 \sim G_2 : \Psi \Rightarrow \Phi $ т.т.т., когда для каждой пары начальных запоминающих устройств $m_1$, $m_2$ такое, что $m_1 \Phi m2$,$ [\![G_1]\!] \ m_1   \sim_\Phi [\![G_2]\!] \ m_2 $ выполняется. Отношение $\sim_\Phi$ является подъемом $\Phi$ к мерам. Если $\Phi$ - PER, то определение $\sim_\Phi$ довольно-таки интуитивно:
\[ \mu_1 \sim_\Phi \mu_2 \myeq \forall a. \mu_1 \ \mathbb{I}_{[a]} = \mu_2 \ \mathbb{I}_{[a]}\]
где $\mathbb{I}_{[a]}$ характеристическая функция класса эквивалентности $a$. Определение $\sim_\Phi$ для произвольных отношений менее очевидное и вовлекает квантор существования:
\begin{align*}
  & range \ P \mu \  & &\myeq \ \forall f. \ (\forall a. \ P a \Rightarrow \ f \ a = 0) \  \Rightarrow \mu \ f = 0 \\
  & \mu_1 \sim_\Phi \mu_2 & &\myeq \  \exists \mu. \ \pi_1 (\mu) = \mu_1 \wedge \pi_2(\mu) = \mu_2 \wedge range \ \Phi \ \mu
\end{align*}
где проекции $\mu$ определены следующим образом
\[ \ \pi_1(\mu) \ \myeq \ bind \ \mu \ (\lambda p.unit \ (fst \ p)) \text{, } \pi_2(\mu) \ \myeq \ bind \ \mu (\lambda p. unit \ (snd \ p)) \]
Это определение следует из работ о вероятностных бисимуляциях и обощает подъем до произвольных соотношений. Оба определения совпадают для PER \cite{11}.
\par
Для того, чтобы анализировать pRHL соотношения, \textbf{CertiCrypt} предоставляет множество выведенных правил и частное (слабое) исчисление предусловий. Правила могут быть найдены в статье \cite{1}. Важное следствие из pRHL суждения $\models G_1 \sim G_2 : \Psi \Rightarrow \Phi $, что если две функции $f$ и $g$ не могут отличить членов памяти в соотношении $\Phi$, то есть
\[ \forall m_1, m_2. \  m_1 \ \Phi \  m_2 \Rightarrow f \ m_1 = g \ m_2\]
тогда
\[ \forall m_1, m_2. \ m_1 \ \Phi \ m_2 \Rightarrow [\![G_1]\!] \ m_1 \ f = [\![G_2]\!] \ m_2 \ g\]
В частности, если $\Phi$ - равенство свободных переменных булевого предиката $A$, мы получаем, что $Pr_{G_1,m_1}[A] = Pr_{G_2,m_2}[A]$. Это свойство продолжается до $\leq$ соотношения.
\par
Специализируя pHRL суждения в предикаты равенства на множестве переменных, можно получить вероятностное невмешательство: при заданном $X$ - множестве переменных, определяем
\[ m_1 =_X m_2 \ \myeq \ \forall x \in X, m_1 \ x = m_2 \ x \]
Вероятностное невмешательство по отношению к набору $I$ входных переменных и набору $O$ выходных переменных определяется как $\models \cdot \sim \cdot := _I \Rightarrow = _O$, мы используем $\models \cdot \simeq^{I}_O  \cdot$ в качестве сокращения.
 
\textbf{CertiCrypt} предоставляет несколько инструментов для обоснования невмешательства. В частности, \textbf{CertiCrypt} реализует несколько тактик, которые помогают установить невмешательство или свести его к более простой цели. Например, тактика \textbf{eqobs\_in} реализует процедуру полурешения для суждений вида $\models c , E \simeq^{I}_O \ c, E'$. Другие тактики, такие как \textbf{eqobs\_hd, eqobs\_tl, eqobs\_ctxt, deadcode} и \textbf{swap}, упрощают цель, используя функции, которые принимают игры $c_1$, $E_1$ и $c_2$, $E_2$ и наборы переменных $I, O$, и возвращают $c_1', c_2'$ и $I', O'$ такие как
\[
\ \models c_1', E_1 \simeq^{I'}_{O'}, c_2', E_2 \Rightarrow  \models c_1, E_1 \simeq^{I}_O, c_2, E_2
\]
 
Тактика отличается своей стратегией вычисления $c_1', c_2'$ и $I', O'$. Тактика \textbf{eqobs\_tl} ищет максимальный общий префикс $c$ такой как $c_1 = c$; $c_1'$ и $c_2 = c$; $c_2'$, \textbf{eqobs\_hd} аналогичным образом ищет максимальный суффикс и \textbf{eqobs\_ctxt} сочетает в себе оба. Тактический обмен перестраивает инструкции в программах для создания наибольшего общего суффикса при сохранении эквивалентности наблюдений, т.е. $c_1' = \hat{c_1}$; $c$ и $c_2' = \hat{c_2}$; $c$ являются перестановками $c_1$ и $c_2$ (и $I' = I$ и $O' = O$). Тактика \textbf{deadcode} создает фрагменты исходных команд, используя переменные в $O$ в качестве критериев среза. Кроме того, \textbf{CertiCrypt} автоматизирует другие распространенные программные преобразования: распространение выражений (\textbf{ep}), распределение переменных (\textbf{alloc}) и встраивание (\textbf{inline}). Показано, что эта тактика позволяет сохранить невмешательство. Тактика \textbf{sinline} сочетает в себе \textbf{inline}, \textbf{alloc}, \textbf{ep} и \textbf{deadcode} в одной мощной тактике.
 
Чтобы иметь возможность справляться с вызовами процедур, тактике необходима информация о процедурах в среде игр. Эта информация не может быть вычислена рекурсивно из-за присутствия злоумышленников, чей код неизвестен. Учитывая две среды $E_1$ и $E_2$ и процедуру $f$, тактика предполагает, что предоставляется следующая информация:
% second half of page 8
Для каждой среды: набор $W_i$ глобальных переменных, которые $f$ может изменять, наборы $I_i$ и $O_i$ глобальных переменных и подмножество $P_i$ его формальных параметров, так что для каждого выполнения тела процедуры конечные значения переменных в $O_i \cup fv (E_i(f).re)$ зависят только от начальных значений переменных во $I_i \cup P_i$. Формально,
\begin{align*}
  W_i = globals(modifies(E_i(f).body, \ E_i)) \wedge \\
  P_i \subseteq E_i(f).params \ \wedge \\
  \models E_i(f).body, \ E_i \simeq^{I_i \cup P_i}_{O_i \cup fv(E_i(f).re)} \ E_i(f).body, \ E_i
\end{align*}

(modifies вычисляет чрезмерную аппроксимацию переменных, измененных фрагментом кода.) Эта информация используется тактиками $swap$, $deadcode$, $ep$ и $inline$; \\
– Реляционная информация: наборы $I$ и $O$ глобальных переменных и набор формальных параметров, так что выполнение тела в каждой среде, начиная с памяти, равнозначно переменным $I \cup P$, приводит к мерам эквивалентными на $O \cup fv(E_i(f).re)$. Далее мы требуем, что $E_1{f}.re = E_2(f).re$. Формально,
\begin{align*}
  P_i \subseteq E_i(f).params \ \wedge P \subseteq E_2(f).params \wedge \\
  \models E_i(f).body, \ E_i \simeq^{I \cup P}_{O \cup fv(E(f).re)} \ E_2(f).body, \ E_2
\end{align*}

% page 9

Эта информация используется тактиками \textit{eqobs\_in}, \textit{eqobs\_hd} и \textit{eqobs\_tl}. CertiCrypt предоставляет несколько механизмов для постепенного и автоматического построения вышеуказанной информации, когда тела процедур в $E_1$ и $E_2$ эквивалентны с точки зрения наблюдений распространению выражений по модулю и устранению мертвого кода. Также возможно получить информацию о противнике из информации о оракулах, которые он может вызвать. Это возможно при условии, что злоумышленник правильно сформирован, поскольку в этом случае мы знаем, что злоумышленник и любые подпроцедуры, которые он может вызвать, уважают политику управления доступом $(\mathcal{O}, \mathcal{RO}, \mathcal{RW})$: они могут вызывать оракулов только в $\mathcal{O}$, читать глобальные переменные в $\mathcal{RO}$ и читать или изменять глобальные переменные в $\mathcal{RW}$. 

Как было сказано ранее, некоторые преобразования, выполняемые во время доказательств, зависят от контекста. CertiCrypt позволяет подробно описать контекст, в котором допустимо преобразование, с использованием программных инвариантов. Таким образом, тактика распространяется на инварианты глобальных переменных; информация, которую они используют, вместо этого указывается в суждениях формы
\begin{equation*}
    |= c_1, E_1 ~ c_2, E_2 :=_{I} \wedge\phi \Rightarrow =_o \wedge \phi|
\end{equation*}

\chapter{Семантическая безопасность хешированного шифрования Эль-Гамаля}

Пусть $G$ - циклическая группа простого порядка $q$ и $g$ - генератор, и пусть $(H_k)_{k \in K}$ - семейство хеш-функций с ключами, отображающих элементы из G в битовые строки определенной длины $\mathcal{l}$. Хешированный Эль-Гамаль - это схема шифрования с открытым ключом, безопасность которой, как считается, связана с проблемой дискретного логарифмирования в $G$. Ее алгоритмы генерации ключей, шифрования и дешифрования определены следующим образом:

\begin{align*}
    &\mathrel{\phantom{=}}KG() & &\mathrel{\phantom{=}} \myeq k \xleftarrow{\$} K; x \xleftarrow{\$} \textbf{Z}_q; \text{return} ((k, x), (k, g^x))\\
    &\mathrel{\phantom{=}}Enc(km \alpha, m) & &\mathrel{\phantom{=}} \myeq y \xleftarrow{\$} \mathbb{Z}_q; h \gets H_k(\alpha^y); \text{ return } (g^y, h, \oplus m) \\
    &\mathrel{\phantom{=}}Dec(k,x,\beta,\zeta) & &\mathrel{\phantom{=}} \myeq h \gets H_k(\beta^x); \text{ return } h \oplus \zeta
\end{align*}

Пространство открытого текста в хешированном Эль-Гамале равно ${0, 1}^{\mathcal{l}}$, в отличие от исходной схемы шифрования Эль-Гамале, пространство открытого текста которой просто $G$. 

В оставшейся части этого раздела мы представляем основанные на играх доказательства семантической безопасности шифрования хешированной схемы Эль-Гамаля в двух разных условиях. Первое доказательство проводится в стандартной модели криптографии; он предполагает, что семейство $(H_k)_{k \in K}$ хеш-функций является сглаживающим по энтропии, и снижает семантическую безопасность до сложности проблемы DDH. Второе доказательство проводится в модели случайного оракула (ROM); она предполагает, что хеш-функции ведут себя как совершенно случайные функции, и снижает семантическую безопасность до уровня сложности (списка) проблемы CDH.


% Page 10
Чтобы формализовать доказательства в \textbf{CertiCrypt}, нам сначала необходимо расширить синтаксис и семантику игр, включив в них типы и операторы, используемые в описании схемы, которые еще не определены. Как объяснено в разделе 3, это делается модульным способом. Мы объявляем семейство циклических групп $(G_\eta)_{\eta \in \mathbb{N}}$, индексируемых параметром безопасности, и расширяем типы языка с помощью определяемых пользователем типов для элементов $G_\eta$ и битовых строк длиной $l$. Мы расширяем $\mathcal{D}$ с помощью равномерного распределения по битовым строкам длины $l$. Мы, наконец, расширяем операторы языка с помощью обнуляющих операторов $q$ и $g$ для извлечения порядка и генератора, соответственно, двоичных операторов для произведения и мощности в группе и $\oplus$ для исключительных или для битовых строк длины $l$. Для доказательства безопасности в стандартной модели мы представляем хеш-функцию схемы в виде двоичного оператора, принимающего ключ $K$  и значение $G_\eta$ и возвращающего битовую строку длиной $l$, тогда как в доказательстве в модели случайного оракула мы непосредственно кодируем хеш-функцию как процедуру, и никаких дополнительных расширений не требуется.


\section{Стойкость в стандартной модели}
Доказательство, которые мы предъявляем опирается на два предположения: предположение, семейство хеш-функций $(H_K)_{k \in K}$ сглаживает энтропию, и DDH. Последнее предположение уже было формализовано ранее. Первое утверждение формализовано ниже:
\textbf{Определение 2 (предположение о сглаживании энтропии).} \textit{Рассмотрим игры}
\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{0.3\textwidth}
    \centering
 \ovalbox{
  \begin{Bflushleft}
    \textbf{Игра $ES_0:$} \\
    $ k \xleftarrow{\$} K$; $h \xleftarrow{\$} \{0,1\}^l$; \\
    $d \gets \mathcal{D}(h)$
  \end{Bflushleft}}
\end{subfigure}
\begin{subfigure}[b]{0.3\textwidth}
  \centering
 \ovalbox{
  \begin{Bflushleft}
    \textbf{Игра $ES_1:$} \\  
    $ k \xleftarrow{\$} K$; $z \xleftarrow{\$} \mathcal{Z}_q$; \\
    $d \gets \mathcal{D}(H(k,g^z))$
  \end{Bflushleft}}
\end{subfigure}
\end{figure}
и определим
\[ \epsilon_{ES(\eta)} \ \myeq \ \lvert Pr_{ES_0}[d = 1] - Pr_{ES_1}[d = 1] \rvert \]
Тогда для каждого PPT злоумышленника $\mathcal{D}$, $\epsilon_{ES(\eta)}$ незначительная функция.
Чтобы не загромождать описание игр, мы немного изменили представление алгоритма генерации ключей: вместо того, чтобы возвращать хэш-ключ как компонент секретного и открытого ключа, мы моделируем его как глобальную переменную $k$. Это позволит нам в то же время хорошо проиллюстрировать использование глобальных переменных в \textbf{CertiCrypt}.

\textbf{Теорема 1 (Стойкость хешированной схемы Эль-Гамаля в стандартной модели).} Для каждого PPT злоумышленника $( \mathcal{A}, \mathcal{A^\prime})$,
\[ \lvert Pr_{IND-CPA}[d] - \frac{1}{2} \rvert \leq \epsilon_{DDH}(\eta) + \epsilon_{ES}(\eta)\]
\textit{Из этого следует, что при предположениях DDH и ES, $Pr_{IND-CPA}[d] $ незначительно стремится к $ \frac{1}{2}$.}

% end
\begin{align*}
    |Pr_{IND-CPA}[b = b'] - \frac{1}{2}| &= |Pr_{G_4}[b = b'] - \frac{1}{2}|\\
    &= |Pr_{G_4}[b = b'] - Pr_{G_6}[b = b']|\\
    &= |Pr_{G_4}[b = b'] - Pr_{G_5}[b = b']|\\
    &\leq Pr_{G_5}[\textbf{bad}]\\
    &\leq Pr_{G_6}[Л \in \text{dom}(\textit{\textbf{L}})]\\
    &= Pr_{LCDH}[g^{xy} \in L']\\
    &= \epsilon_{LCDH}(\eta)
\end{align*}

Из приведенного выше уравнения и согласно допущению списка CDH  (или, что эквивалентно,
при простом предположении CDH), преимущество IND-CPA противника $(A, A')$
результаты пренебрежимо близки к $\frac{1}{2}$. Чтобы убедиться в этом, достаточно проверить, что противник $C$
выполняется за вероятностное полиномиальное время. Это так, потому что противник $(A, A')$
выполняет, а $C$ не выполняет дорогостоящих вычислений.

\chapter{Похожие работы}

Эль-Гамаль - это стандартный пример криптографического доказательства, основанного на игре, который обеспечивает эталонный тест, с которым можно сравнивать другие работы. Кратко прокомментируем три доказательства, тесно связанных с нашим. Для более общего описания связанных работ мы отсылаем к \cite{1}. 
Самым последним и тесно связанным с этим является формализация в Coq основанного на игре доказательства семантической безопасности Эль-Гамаля, выполненная Новаком \cite{12}. Хотя мы выбираем глубокое встраивание, Новак использует неглубокое встраивание и моделирует противников напрямую как функции Coq. Как следствие, получившаяся структура обеспечивает лишь ограниченную поддержку автоматизации проверки. По той же причине формализация Новака не может иметь дело со случайными оракулами, поэтому он представляет только доказательство Хешированного Эль-Гамаля в стандартной модели криптографии. Наконец, неясно, как формализовать сложность в контексте неглубокого внедрения, а формализация Новака полностью игнорирует сложность; в результате предположения безопасности, такие как $DDH$, не могут быть точно смоделированы. 
Более ранняя работа Барта, Седерквиста и Таренто \cite{13} предоставляет основы формального доказательства безопасности подписанного шифрования Эль-Гамаля в Coq. В отличие от нашей работы, они рассматривают идеализированную модель криптографии, которая абстрагирует многие детали системы и определения безопасности. Таким образом, связь между формализацией и заявлением о безопасности не так сильна, как хотелось бы. 
Корин и ден Хартог \cite{14} разработали (нереляционную) логику Хоара для рассуждений о вероятностных алгоритмах. Они использовали его для построения доказательства семантической безопасности шифрования Эль-Гамаля, но нам не известно о какой-либо другой системе, проверяемой с использованием этой логики. Поскольку они основаны на простом вероятностном расширении логики Хоара, их формализм недостаточно выразителен, чтобы моделировать понятие сложности $PPT$, и поэтому цели и гипотезы безопасности не могут быть точно выражены. В более общем смысле, логика сама по себе не предоставляет средств для рассуждений о контекстно-зависимых преобразованиях программ или преобразованиях, выполненных в оракулах.

\section{Заключение}

CertiCrypt - это полностью формализованный фреймворк, который помогает создавать криптографические игровые доказательства. Доказательства в CertiCrypt полагаются на минимальную надежную базу, и их правильность может быть автоматически проверена третьими сторонами. В этой статье мы проиллюстрировали некоторые ключевые аспекты CertiCrypt посредством формализации семантических доказательств безопасности схемы шифрования с открытым ключом хешированная схема Эль-Гамаля в стандартной и случайной модели оракула, и мы выделили некоторые существенные различия между нашими доказательствами и теми, которые появляются. в литературе. 
\textit{Благодарности} Мы хотели бы поблагодарить Дэниела Хедина за его полезные комментарии к более раннему черновику этой работы.

\nocite{*}

\bibliographystyle{plain}
\bibliography{mybib.bib}

\chapter{Информация о курсовой}


\section{Рабочее окружение}

Emacs + AuCTex + yaSnippet

\section{Инструкция по сборке}

\begin{enumerate}
  \item Запустить pdflatex ElGamal.tex 
  \item Запустить bibtex ElGamal.aux
  \item Запустить pdflatex ElGamal.tex
\end{enumerate}
\section{Компилятор}

$\bullet$ LaTex

\section{Поля и шрифты}

\begin{itemize}
\item \textit{Размеры полей:} top = 20 mm, bottom = 20 mm, left = 25 mm, right = 15 mm. 
\item \textit{Размер шрифта:} 12pt.
\end{itemize}

\section{Стилевые пакеты}

\begin{enumerate}
\item russian  - поддержка русского языка
\item amsmath - математические символы для написания формул
\item amssymb - различные математические шрифты
\item multicol - для разделения текста на колонки
\item color - позволяет задавать цвет текста и фона
\item geometry - настройки полей 
\item hyperref - гиперссылки 
\item graphicx - для вставки изображений в документ
\item fancybox - красивые коробочки
\end{enumerate}

\section{Кастомная команда и сниппеты}

\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}} - def над знаком равно \myeq

\section{Ссылка на репозиторий }

\url{https://github.com/papagvas/latexElGamal/}

\end{document}